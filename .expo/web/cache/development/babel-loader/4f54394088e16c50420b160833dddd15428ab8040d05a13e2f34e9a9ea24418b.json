{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { EventEmitter } from 'fbemitter';\nimport * as logger from './logger';\nexport var MESSAGE_PROTOCOL_VERSION = 2;\nexport var DevToolsPluginMethod = 'Expo:DevToolsPlugin';\nexport var DevToolsPluginClient = function () {\n  function DevToolsPluginClient(connectionInfo) {\n    var _this = this;\n    _classCallCheck(this, DevToolsPluginClient);\n    this.eventEmitter = new EventEmitter();\n    this.handleMessage = function (event) {\n      var payload;\n      try {\n        payload = JSON.parse(event.data);\n      } catch (e) {\n        logger.info('Failed to parse JSON', e);\n        return;\n      }\n      if (payload.version !== MESSAGE_PROTOCOL_VERSION || payload.method !== DevToolsPluginMethod) {\n        return;\n      }\n      if (payload.pluginName && payload.pluginName !== _this.connectionInfo.pluginName) {\n        return;\n      }\n      _this.eventEmitter.emit(payload.params.method, payload.params.params);\n    };\n    this.connectionInfo = connectionInfo;\n  }\n  _createClass(DevToolsPluginClient, [{\n    key: \"addMessageListener\",\n    value: function addMessageListener(method, listener) {\n      return this.eventEmitter.addListener(method, listener);\n    }\n  }, {\n    key: \"addMessageListenerOnce\",\n    value: function addMessageListenerOnce(method, listener) {\n      this.eventEmitter.once(method, listener);\n    }\n  }]);\n  return DevToolsPluginClient;\n}();","map":{"version":3,"names":["EventEmitter","logger","MESSAGE_PROTOCOL_VERSION","DevToolsPluginMethod","DevToolsPluginClient","connectionInfo","_this","_classCallCheck","eventEmitter","handleMessage","event","payload","JSON","parse","data","e","info","version","method","pluginName","emit","params","_createClass","key","value","addMessageListener","listener","addListener","addMessageListenerOnce","once"],"sources":["/Users/yavuzceliker/Desktop/projects/yavuz/react/qr4car/mobile/node_modules/expo/src/devtools/DevToolsPluginClient.ts"],"sourcesContent":["import { EventEmitter, EventSubscription } from 'fbemitter';\n\nimport type { ConnectionInfo } from './devtools.types';\nimport * as logger from './logger';\n\n// This version should be synced with the one in the **createMessageSocketEndpoint.ts** in @react-native-community/cli-server-api\nexport const MESSAGE_PROTOCOL_VERSION = 2;\n\nexport const DevToolsPluginMethod = 'Expo:DevToolsPlugin';\n\n/**\n * This client is for the Expo DevTools Plugins to communicate between the app and the DevTools webpage hosted in a browser.\n * All the code should be both compatible with browsers and React Native.\n */\nexport abstract class DevToolsPluginClient {\n  protected eventEmitter: EventEmitter = new EventEmitter();\n\n  public constructor(public readonly connectionInfo: ConnectionInfo) {}\n\n  /**\n   * Initialize the connection.\n   * @hidden\n   */\n  public abstract initAsync(): Promise<void>;\n\n  /**\n   * Close the connection.\n   */\n  public abstract closeAsync(): Promise<void>;\n\n  /**\n   * Send a message to the other end of DevTools.\n   * @param method A method name.\n   * @param params any extra payload.\n   */\n  public abstract sendMessage(method: string, params: any): void;\n\n  /**\n   * Subscribe to a message from the other end of DevTools.\n   * @param method Subscribe to a message with a method name.\n   * @param listener Listener to be called when a message is received.\n   */\n  public addMessageListener(method: string, listener: (params: any) => void): EventSubscription {\n    return this.eventEmitter.addListener(method, listener);\n  }\n\n  /**\n   * Subscribe to a message from the other end of DevTools just once.\n   * @param method Subscribe to a message with a method name.\n   * @param listener Listener to be called when a message is received.\n   */\n  public addMessageListenerOnce(method: string, listener: (params: any) => void): void {\n    this.eventEmitter.once(method, listener);\n  }\n\n  /**\n   * Returns whether the client is connected to the server.\n   */\n  public abstract isConnected(): boolean;\n\n  protected handleMessage = (event: WebSocketMessageEvent): void => {\n    let payload;\n    try {\n      payload = JSON.parse(event.data);\n    } catch (e) {\n      logger.info('Failed to parse JSON', e);\n      return;\n    }\n\n    if (payload.version !== MESSAGE_PROTOCOL_VERSION || payload.method !== DevToolsPluginMethod) {\n      return;\n    }\n    if (payload.pluginName && payload.pluginName !== this.connectionInfo.pluginName) {\n      return;\n    }\n\n    this.eventEmitter.emit(payload.params.method, payload.params.params);\n  };\n}\n"],"mappings":";;AAAA,SAASA,YAAY,QAA2B,WAAW;AAG3D,OAAO,KAAKC,MAAM,MAAM,UAAU;AAGlC,OAAO,IAAMC,wBAAwB,GAAG,CAAC;AAEzC,OAAO,IAAMC,oBAAoB,GAAG,qBAAqB;AAMzD,WAAsBC,oBAAoB;EAGxC,SAAAA,qBAAmCC,cAA8B;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAH,oBAAA;IAAA,KAFvDI,YAAY,GAAiB,IAAIR,YAAY,EAAE;IAAA,KA6C/CS,aAAa,GAAG,UAACC,KAA4B,EAAU;MAC/D,IAAIC,OAAO;MACX,IAAI;QACFA,OAAO,GAAGC,IAAI,CAACC,KAAK,CAACH,KAAK,CAACI,IAAI,CAAC;OACjC,CAAC,OAAOC,CAAC,EAAE;QACVd,MAAM,CAACe,IAAI,CAAC,sBAAsB,EAAED,CAAC,CAAC;QACtC;;MAGF,IAAIJ,OAAO,CAACM,OAAO,KAAKf,wBAAwB,IAAIS,OAAO,CAACO,MAAM,KAAKf,oBAAoB,EAAE;QAC3F;;MAEF,IAAIQ,OAAO,CAACQ,UAAU,IAAIR,OAAO,CAACQ,UAAU,KAAKb,KAAI,CAACD,cAAc,CAACc,UAAU,EAAE;QAC/E;;MAGFb,KAAI,CAACE,YAAY,CAACY,IAAI,CAACT,OAAO,CAACU,MAAM,CAACH,MAAM,EAAEP,OAAO,CAACU,MAAM,CAACA,MAAM,CAAC;IACtE,CAAC;IA5DkC,KAAAhB,cAAc,GAAdA,cAAc;EAAmB;EAACiB,YAAA,CAAAlB,oBAAA;IAAAmB,GAAA;IAAAC,KAAA,EAyB9D,SAAAC,mBAAmBP,MAAc,EAAEQ,QAA+B;MACvE,OAAO,IAAI,CAAClB,YAAY,CAACmB,WAAW,CAACT,MAAM,EAAEQ,QAAQ,CAAC;IACxD;EAAC;IAAAH,GAAA;IAAAC,KAAA,EAOM,SAAAI,uBAAuBV,MAAc,EAAEQ,QAA+B;MAC3E,IAAI,CAAClB,YAAY,CAACqB,IAAI,CAACX,MAAM,EAAEQ,QAAQ,CAAC;IAC1C;EAAC;EAAA,OAAAtB,oBAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}